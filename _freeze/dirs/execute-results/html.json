{
  "hash": "914976a102c832bb23af0e08ee1ad29b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#'\n---\n\n\n\n\n\n# Directories {#sec-dirs}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-warning collapse='false' appearance='default' icon='false'}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is being revised. Thank you for your patience.\n\n::: \n\n::::\n\n\n\n\n\nWhen presented with a new map, the most important thing to find is your location on it (it's hard to know where you're going without knowing where you are). In Linux, directories are more than just containers for files; they are a critical part of the hierarchical file system, which is organized in a tree-like structure starting from the root directory (`/`).\n\n## [Root Directory]{style=\"font-size: 1.05em; font-weight: bold;\"} \n\nThe root directory is the topmost directory in the Linux file system hierarchy. All other directories and files are nested within it. It is represented by a single forward slash `/` and contains critical system directories like `/bin`, `/etc`, `/home`, and `/var`.\n\n\n\n\n\n```{=html}\n\n<style>\n\n.codeStyle span:not(.nodeLabel) {\n  font-family: monospace;\n  font-size: 1.75rem;\n  font-weight: bold;\n  color: #9753b8 !important;\n  background-color: #faf9ed;\n  padding: 0.2em;\n}\n\n</style>\n```\n\n```{mermaid}\n%%| fig-cap: 'Everything is a file'\n%%| fig-align: center\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\n\nflowchart TD\n  Root(<code>/</code>)\n  bin(<code>/bin</code>)\n  etc(<code>/etc</code>)\n  home(<code>/home</code>)\n  usr(<code>/usr</code>)\n  var(<code>/var</code>)\n  tmp(<code>/tmp</code>)\n\n  Root --> bin\n  Root --> etc\n  Root --> home\n  Root --> usr\n  Root --> var\n  Root --> tmp\n```\n\n\n\n\n\n### Subdirectories\n\nBeneath the root directory, the Linux file system is organized into various subdirectories, each serving specific purposes:\n\n`/bin` – Contains essential user command binaries \n\n`/etc` – Stores system-wide configuration files.\n\n`/home` – Houses personal directories for each user.\n\n`/var` – Contains variable data like logs and spool files.\n\nIn Linux systems, the `~` represents the user's 'home' directory.\n\n### File paths\n\nA file path is a character string specifying the unique location of a file or directory within the hierarchical file system. File paths can be **absolute** (starting from the root  (`/`) directory) or **relative** (starting from the current (`.`) directory). \n\n## [Navigate]{style=\"font-size: 1.05em; font-weight: bold;\"}  {#sec-nav-dirs}\n\n### `pwd`\n\n**<code>@sec-pwd</code>** (print working directory) tells you exactly where you are in the filesystem.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npwd \n# /Users/username/projects/books/fm-linux\n```\n:::\n\n\n\n\n\n[]{style=\"font-size: 1.25em; font-weight: bold; font-style: italic;\"} \n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nThe output from `pwd` is the file path to our local working directory.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ~\npwd\n# /Users/username\n```\n:::\n\n\n\n\n\n\n### `tree`\n\nThe `tree` command will recursively print the directory structure of a file path in a 'tree-like' format, visually representing the hierarchy of files and directories.\n\nBelow is an example 'folder tree' for the current working directory returned from the `pwd` command above:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# /Users/ \n#   └─ username/ -> represented as '~'\n#        └─ project/ \n#             └─ books/ \n#                 └─ fm-linux/\n```\n:::\n\n\n\n\n\n\nThe output from `pwd` is an absolute file path, and **absolute file paths** do not change regardless of the current working directory. \n\n### `cd`\n\nMove from one directory to another with **<code>@sec-cd</code>** (change directory). For example, `cd data` takes you to the `data` folder *inside* our current working directory.  \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd data\n```\n:::\n\n\n\n\n\nIn the command above, `data` is a relative file path. **Relative file paths** specify the location of a file *relative to the current working directory*.\n\n:::{layout=\"[50,50]\" layout-valign=\"top\"}\n\nIf we view our current directory with `tree` after changing it to `data`, we see the current location listed as `.`:\n\n``` sh\ncd data \ntree -d\n# .\n# └── raw\n# \n# 2 directories\n```\n\n:::\n\nIt's important to notice the difference between absolute and relative paths, because it makes it easier to navigate the operating system and manipulate files and folders.\n\nFor example, can use a relative file path to view the `report.txt` file in the `data` folder with `cat`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd data\ncat report.txt\n# my important information\n```\n:::\n\n\n\n\n\n`data/report.txt` is the relative file path (i.e., relative to the current working directory), and it's meaning is based on the directory from which it is referenced.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n### `ls`\n\n**<code>@sec-ls</code>** (list) lists the files and folders in a given location. In `/bin`, `ls` would show you the software tools available:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd /bin # change location\nls # what's in here?\n# [\n# bash\n# cat\n# chmod\n# cp\n# csh\n# dash\n# date\n# dd\n# df\n# echo\n# ed\n# expr\n# hostname\n# kill\n# ksh\n# launchctl\n# link\n# ln\n# ls\n# mkdir\n# mv\n# pax\n# ps\n# pwd\n# realpath\n# rm\n# rmdir\n# sh\n# sleep\n# stty\n# sync\n# tcsh\n# test\n# unlink\n# wait4path\n# zsh\n```\n:::\n\n\n\n\n\n\n### `find`\n\n**<code>@sec-find</code>** can be used to locate files *or* directories using the `-type` and `-name` options. The example below looks in the current working directory (`.`) for a folder named `data`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfind . -type d -name data\n# ./data\n```\n:::\n\n\n\n\n\n## [Manage]{style=\"font-size: 1.05em; font-weight: bold;\"}  {#sec-manage-dirs}\n\nIn the Linux world, file and directory management is a fundamental skill. This chapter introduces some common commands that will allow you to create, copy, move, remove, and link files and directories. \n\n### `mkdir`\n\n**<code>@sec-mkdir</code>** (Make Directory) builds a new folder wherever you tell it to, like making a new folder in data for inputs (`data/in`) or outputs (`data/out`) \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmkdir data/in\nmkdir data/out\n```\n:::\n\n\n\n\n\nConfirm with `tree -d` (the `-d` is for directories):\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data -d\n# data\n# ├── in\n# └── out\n# \n# 3 directories\n```\n:::\n\n\n\n\n\n### `cp`\n\n**<code>@sec-cp</code>** duplicates files or folders. The `cp` command is used to copy files or directories from one location to another. Imagine having a file (`binary_data.tsv`) on your root (`.`) directory that you want to copy to the `/data/in` folder; you could use `cp` to make a duplicate. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncp binary_data.tsv data/in/binary_data.tsv\n```\n:::\n\n\n\n\n\nConfirm with `tree`\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data/in\n# data/in\n# └── binary_data.tsv\n# \n# 1 directory, 1 file\n```\n:::\n\n\n\n\n\n### `mv`\n\n**<code>@sec-mv</code>**, short for move, moves files or directories from one location to another. We'll use it to move `data/binary_data.tsv` to `data/out/binary_data.tsv`:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# move file\nmv data/in/binary_data.tsv data/out/binary_data.tsv \n```\n:::\n\n\n\n\n\nConfirm move with `tree`:[^tree-pattern]\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntree data -P *.tsv\n# data\n# ├── in\n# └── out\n#     └── binary_data.tsv\n# \n# 3 directories, 1 file\n```\n:::\n\n\n\n\n\n[^tree-pattern]: The `-P *.tsv` option for `tree` tells it to look in `data` for files or folders with a `.tsv` extension. We'll cover wildcards and patterns in the @sec-symbols-patterns chapter.\n\nIt can also be used for renaming files. \n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# rename file\nmv data/out/binary_data.tsv  data/out/bin_dat.tsv \n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# confirm rename \ntree data/out\n# data/out\n# └── bin_dat.tsv\n# \n# 1 directory, 1 file\n```\n:::\n\n\n\n\n\n`mv` is especially useful for organizing files and directories that are in the wrong place.\n\n### `rm`\n\nThe **<code>@sec-rm</code>** command stands for **remove** and is used to delete files or directories.\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# remove doc folder\nrm data/out\n# rm: data/out: is a directory\n```\n:::\n\n\n\n\n\nBy default, it won't remove a directory without the `-R` or `-r` option.\n\n\n\n\n\n\n:::: {.callout-warning collapse='false' appearance='default' icon='false'}\n\n## [Warning]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.05em; color: #282b2d;'}\n\n\n\n\nIt's important to note here that the command-line is not very forgiving. Using `rm` is a powerful action with significant consequences, as it permanently deletes files, akin to shredding documents. There's usually no easy way to recover deleted files unless you have a backup.\n\n> '*Linux is like a chainsaw. Chainsaws are powerful tools, and make many difficult tasks like cutting through thick logs quite easy. Unfortunately, this power comes with danger: chainsaws can cut just as easily through your leg.*' - Gary Bernhardt[^bernhardt]\n\n[^bernhardt]: As quoted in [Bioinformatics Data Skills: Reproducible and Robust Research with Open Source Tools (2015) by Vince Buffalo](https://bit.ly/3sVBSne).\n\n\n\n::: \n\n::::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# add option \nrm -R data/out\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## [Recap]{style=\"font-size: 1.05em; font-weight: bold;\"} \n\nGiven the principle that **everything is a file** in Linux, directories are treated as special types of files that contain references to other files and directories, facilitating the organization and management of data. \n\nUnderstanding how to navigate, manipulate, and manage directories is essential for effective use of the Linux operating system. \n\n\n\n\n\n\n:::: {.callout-note collapse='false' appearance='simple' icon=false}\n\n## [See a typo, error, or something missing?]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nPlease open an issue on [GitHub.](https://github.com/mjfrigaard/fm-linux/issues/new)\n\n::: \n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}