{
  "hash": "c916c12f3bb9e2a4df2dde6e396425b7",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n\n\n\n# Shells {#sec-shells}\n\n\n\n\n\n\n\n\n\n\n:::: {.callout-warning collapse='false' appearance='default' icon='false'}\n\n## [Caution]{style='font-weight: bold; font-size: 1.25em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\nThis section is being revised. Thank you for your patience.\n\n::: \n\n::::\n\n\n\n\n\nFramed in the context of the car manufacturers analogy, @sec-shells are the car's dashboards and controls--the interface between the driver and the carâ€™s engine. Shells translate commands into actions a computer can understand and execute. Below I'll cover two popular shells: Bash and Zsh.[^fish]\n\n[^fish]: The appendix also covers the key features and customizations of the [Fish shell](fish.qmd)\n\n## [The Command Interpreter]{style=\"font-weight: bold;\"} \n\nA **Shell** is a program that interprets commands (i.e., the 'command interpreter') and acts as an intermediary between the user and the kernel of the operating system. Shells can be either command-line based or graphical. \n\nThe available shells are stored in `/etc/shells`, and we can view them with the command below:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat /etc/shells\n## # List of acceptable shells for chpass(1).\n## # Ftpd will not allow users to connect who are not using\n## # one of these shells.\n## \n## /bin/bash\n## /bin/csh\n## /bin/dash\n## /bin/ksh\n## /bin/sh\n## /bin/tcsh\n## /bin/zsh\n```\n:::\n\n\n\n\n\n### Picking a shell\n\nTo change the default shell, use the <strong><code>@sec-chsh</code></strong>  command (change shell). For example, if you want to switch to `bash`, use the command below:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nchsh -s /bin/bash\n```\n:::\n\n\n\n\n\nYou can use the <strong><code>@sec-echo</code></strong> and <strong><code>@sec-ps</code></strong> commands to verify the shell you're currently using:\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho $SHELL\n# /bin/bash\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nps -p $$\n#   PID TTY           TIME CMD\n# 16082 ttys003    0:00.02 -bash\n```\n:::\n\n\n\n\n\n## ![](img/bash-logo.svg){fig-align=\"right\" width=\"12%\"} [Bash]{style=\"font-weight: bold;\"} {#sec-bash}\n\nIntroduced in 1989, [**Bash, or the Bourne Again SHell**](https://www.gnu.org/software/bash/) has become the default command-line interface or shell for most Linux distributions. Incorporating features from the Korn shell ([`ksh`](https://en.wikipedia.org/wiki/KornShell)) and the C shell ([`csh`](https://en.wikipedia.org/wiki/C_shell)), Bash supports features like command history, tab completion, aliases and scripting tasks.[^sh_term-1]\n\n[^sh_term-1]: Bash was the default command-line interface for Apple's macOS (which is Linux-based) until the transition to `zsh` as the default shell in [macOS Catalina.](https://support.apple.com/en-us/102360)\n\n### Key features\n\n**Programming**\n\nBash includes an array of programming constructs for scripting:\n\n-   Conditional statements (`if`, `then`, `else`, `elif`, `fi`)\\\n-   Looping statements (`for`, `while`, `until`)\n\n**Interactive Command Line Editing**\n\nBash provides an interactive command line editing environment where users can navigate and edit commands directly on the command line using Emacs or Vi editing modes.\n\n**History expansion**\n\nCommands can be re-executed by recalling them from the history.\n\n**Tab Completion**\n\nBash supports tab completion for command names, file names, and even command arguments, speeding up the input process and reducing typos.\n\n**Comprehensive Job Control**\n\n-   Backgrounding (`&`), foregrounding (`fg`), and job management (`jobs`, `bg`)\\\n-   Stopping (suspending) processes and continuing them with `kill` and `kill -CONT`\n\n**Aliases**\n\nUsers can create shorter commands to represent longer sequences of commands using aliases.\n\n**Shell Functions**\n\nBash also supports more powerful functions that can take arguments like small scripts.\n\n**Script Debugging**\n\nBash scripts can be debugged using options like `set -x` to print commands and their arguments as they are executed, which is invaluable for troubleshooting scripts.\n\n**Environment Control**\n\n-   Environment variables configuration and management\n-   Variables are exported to make them available to sub-processes\n\n**Expansion Capabilities**\n\nBash supports several types of expansions that enhance its scripting capabilities:\n\n-   Brace expansion: `{a,b,c}`\n-   Tilde expansion: `~` translates to the home directory.\n-   Parameter and variable expansion: `$name` or `${name}`\n-   Arithmetic expansion: `$(( expression )0`\n\n**History Features**\n\nBash maintains a history of commands that users have executed, which can be navigated, searched, and reused. It also supports configuring the history size and behavior through various environment variables like `HISTSIZE` and `HISTFILESIZE`.\n\n\n## ![](img/zshell-logo.png){fig-align=\"right\" width=\"12%\"} [Zsh]{style=\"font-weight: bold;\"}\n\n[**Zsh (Z Shell or 'Oh My ZSH!')**](https://ohmyz.sh/) is noted for its interactive features and is often used with customization frameworks. Zsh is a powerful command-line interpreter for Linux systems that serves as both a scriptable shell and an interactive command interpreter.[^sh_term-2]\n\n[^sh_term-2]: Zsh is an [extended version](https://en.wikipedia.org/wiki/Z_shell) of **Bash (Bourne Again SHell)**, with many improvements, and is fully compatible with the Bourne Shell.\n\n\n### Key features\n\n**Command Line Editing**\n\nZsh provides an advanced and customizable command-line editing environment. Users can configure key bindings and have extensive control over the text editing capabilities directly within the command prompt.\n\n**Tab Completion**\n\nZsh has one of the most powerful tab completion systems. It supports:\n\n-   Completion for command options and arguments.\n-   Automatic listing of options when a tab is hit twice.\n-   Context-sensitive completion that can recognize patterns in filenames, history, running processes, hostnames, and more.\n\n**Themes and Prompts**\n\nZsh allows extensive customization of its prompt, supporting themes that can completely change the look of your command line. The prompt can include colors, content from shell variables, functions, and command outputs.\n\n**Scripting**\n\nZsh scripting is robust, with features like arrays, associative arrays, and floating-point arithmetic which are not typically available in all shells. It enhances scripting capabilities and improves on the scripting syntax of the Bourne Shell.\n\n**Loadable Modules**\n\nZsh supports dynamically loadable modules, expanding its capabilities with features like:\n\n-   FTP client\n-   TCP and UDP socket operations\n-   Advanced math functions\n-   Full-fledged regular expression matching\n\n**Improved Variable Handling**\n\nVariable handling in Zsh includes several enhancements like:\n\n-   Better array handling\n-   Associative arrays (similar to dictionaries in higher-level programming languages)\n-   Easier string manipulation and pattern matching\n\n**Spell Check and Correction**\n\nZsh can be configured to correct commands automatically if misspelled and to suggest corrections or alternatives. This feature helps in reducing syntax errors and improves user efficiency.\n\n**Extended Globbing**\n\nZsh's file globbing allows for more complex pattern matching than traditional Linux shells. You can specify patterns in a more expressive and powerful way, which is particularly useful in scripts.\n\n## [Customizations]{style=\"font-weight: bold;\"} \n\nCustomizing the shell environment can significantly enhance your productivity by tailoring it to your specific needs and preferences. The next sections cover come basic customizations for Bash and Zsh.\n\n### Prompts {#sec-shell-prompts}\n\n![](img/bash-logo.svg){fig-align=\"right\" width=\"10%\"} [Bash]{style=\"font-size: 1.05em;\"}\n\nBash offers a wide range of customization options through the `.bash_profile` file, which is sourced every time a new terminal session is started.\n\nThe `PS1` variable defines the appearance of your command prompt. Use `export PS1=` to customize the prompt in the `~/.bash_profile` file:[^prompt-vars]\n\n:::{layout=\"[50,50]\" layout-valign=\"bottom\"}\n\n``` sh\n# in ~/.bash_profile\nexport PS1=\"Bash@MacBook \\W\\$ \"\n```\n\n``` sh\n# prompt\nBash@MacBook ~$ \n```\n\n:::\n\n\n[^prompt-vars]: `\\W` prints the basename of the current working directory. You can also specify the username (`\\u`) and the host name up to the first period (`\\h`).\n\nBelow we'll customizes the prompt to show `Bash` in green, `@MacBook` in blue, and the current working directory (`\\W`) in red, followed by a dollar sign (`$`).\n\n**Defining ANSI Colors in `~/.bash_profile`**\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code .code-overflow-wrap}\n# define colors\nGREEN=\"\\[\\e[32m\\]\"\nBLUE=\"\\[\\e[34m\\]\"\nRED=\"\\[\\e[31m\\]\"\nRESET=\"\\[\\e[0m\\]\"\n```\n:::\n\n\n\n\n\n- `GREEN=\"\\[\\e[32m\\]\"`: ANSI escape code for green  \n- `BLUE=\"\\[\\e[34m\\]\"`: ANSI escape code for blue  \n- `RED=\"\\[\\e[31m\\]\"`: ANSI escape code for red  \n- `RESET=\"\\[\\e[0m\\]\"`: Resets color back to default terminal color \n\n**Using Colors in `PS1`**\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code .code-overflow-wrap}\n# customize PS1 prompt with colors\nexport PS1=\"${GREEN}Bash${RESET}${BLUE}@MacBook${RESET} ${RED}\\W${RESET}\\$ \"\n```\n:::\n\n\n\n\n\n\n- `${GREEN}`: Inserts green color before `Bash`   \n- `${RESET}`: Resets the color after `Bash` and `MacBook` to ensure that only `Bash` and `MacBook` are colored  \n- `${BLUE}`: Inserts the blue color before `@MacBook`   \n- `${RED}`: Inserts the red color before the working directory (`\\W`)  \n- `${RESET}` at the end ensures that the prompt returns to the default color after displaying the prompt  \n\nAfter updating the `~/.bash_profile` file, run `source ~/.bash_profile` to apply the changes to the current session.\n\n![Customized prompt on bash shell](img/bash_prompt_cust.png){width='100%' fig-align='center'}\n\n\n\n![](img/zshell-logo.png){fig-align=\"right\" width=\"10%\"} [Zsh]{style=\"font-size: 1.05em;\"}\n\nCustomizations in Zsh are similar to Bash, but they done using the `.zshrc` file. Zsh has `PROMPT` variable to customize the prompt, but with more advanced capabilities:\n\n```zsh\n# Define color variables\nGREEN=\"%F{green}\"\nBLUE=\"%F{blue}\"\nRED=\"%F{red}\"\nRESET=\"%f\"\n\n# Customize the prompt using the variables\nexport PROMPT=\"${GREEN}Zsh${RESET}${BLUE}@MacBook${RESET} ${RED}<%~>${RESET} \"\n```\n\n\n\n\n### Aliases {#sec-shell-aliases}\n\nAliases allow you to create shortcuts for commonly used commands.\n\n![](img/bash-logo.svg){fig-align=\"right\" width=\"10%\"} [Bash]{style=\"font-size: 1.05em;\"} \n\n**Bash aliases**: These aliases simplify the `ls -la` command to `ll` and `git status` to `gs`.\n  \n```sh\nalias ll='ls -la --color=auto'\nalias gs='git status'\n```\n\n![](img/zshell-logo.png){fig-align=\"right\" width=\"10%\"} [Zsh]{style=\"font-size: 1.05em;\"} \n\n**Zsh Aliases**: Zsh supports aliases in a similar manner to Bash.\n\n```sh\nalias ll='ls -lh'\n```\n\n### Functions\n\n![](img/bash-logo.svg){fig-align=\"right\" width=\"10%\"} [Bash]{style=\"font-size: 1.05em;\"} \n\n**Bash Functions**: Bash functions allow you to create reusable scripts within your shell environment.\n\n  \n```sh\nfunction mkcd() {\n    mkdir -p \"$1\" && cd \"$1\";\n}\n```\n\nThe `mkcd` function creates a directory and then navigates into it.\n\n![](img/zshell-logo.png){fig-align=\"right\" width=\"10%\"} [Zsh]{style=\"font-size: 1.05em;\"} \n\n**Zsh Functions**: Zsh supports functions in a similar manner to Bash.\n\n```sh\nfunction extract() {\n    if [ -f $1 ]; then\n        case $1 in\n            *.tar.bz2)   tar xjf $1   ;;\n            *.tar.gz)    tar xzf $1   ;;\n            *.bz2)       bunzip2 $1   ;;\n            *.rar)       unrar e $1   ;;\n            *.gz)        gunzip $1    ;;\n            *.tar)       tar xf $1    ;;\n            *.tbz2)      tar xjf $1   ;;\n            *.tgz)       tar xzf $1   ;;\n            *.zip)       unzip $1     ;;\n            *.Z)         uncompress $1;;\n            *.7z)        7z x $1      ;;\n            *)           echo \"don't know how to extract '$1'...\" ;;\n        esac\n    else\n        echo \"'$1' is not a valid file!\"\n    fi\n}\n```\n\n\n\n### Advanced \n\nBelow we cover some advanced customizations.\n\n![](img/bash-logo.svg){fig-align=\"right\" width=\"10%\"} [Bash]{style=\"font-size: 1.05em;\"} \n\n**Bash Completion**\n\nEnhance command-line efficiency by enabling tab completion for various commands.\n\n```sh\nif [ -f /etc/bash_completion ]; then\n    . /etc/bash_completion\nfi\n```\n\n![](img/zshell-logo.png){fig-align=\"right\" width=\"10%\"} [Zsh]{style=\"font-size: 1.05em;\"}\n\n**Oh My Zsh**\n\nA popular framework for managing Zsh configuration, making it easy to apply themes and plugins.\n\n```sh\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\nOnce installed, you can easily switch themes by editing the `ZSH_THEME` variable in your `.zshrc` file.\n\n```sh\nZSH_THEME=\"agnoster\"\n```\n\n**Zsh Completions and Plugins**\n\nZsh offers extensive tab-completion support and a variety of plugins that can be enabled for additional functionality.\n\n```sh\nplugins=(git docker kubectl)\n```\n\n\n\n\n\n\n\n\n\n:::: {.callout-tip collapse='true' appearance='default' icon='false'}\n\n## [Changing prompts in Zsh]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.00em; color: #282b2d;'}\n\n\n\n\n1. Open your `.zshrc` file in your home directory with a text editor.\n\n    ``` sh\n    ~/.zshrc\n    ```\n\n2. Add or change the line that defines `PROMPT`. For example:\n\n    ``` sh\n    export PROMPT=\"Zsh@MacBook %1~%% \"\n    ```\n\nThis sets a prompt similar to Bash's example above.\n\n``` sh\nZsh@MacBook ~% \n```\n\n3. Save the file and apply the changes by sourcing the profile:\n\n    ``` sh\n    source ~/.zshrc\n    ```\n\n\n\n::: \n\n::::\n\n\n\n\n\n\n## [Recap]{style=\"font-size: 1.05em; font-weight: bold;\"}\n\nIf Linux is the environment *where* the heavy lifting of computing happens--managing files, running programs, and controlling hardware--then the shell commands are the language and syntax that spell out *what* computational work happens. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}